# GraphRAG Evaluation for PM Intelligence System

## Decision Date
2026-02-16

## Current State Analysis

### What We Have
1. **Neo4j Knowledge Graph**
   - Entity nodes (customers, features, issues, themes)
   - Relationship edges (mentions, relates_to, derived_from)
   - Built-in graph algorithms (Louvain, PageRank, Label Propagation)
   - Cypher for multi-hop traversal

2. **PostgreSQL Opportunity Detection**
   - Signal clustering based on entity overlap
   - Theme hierarchy for categorization
   - RICE scoring for prioritization
   - Trend analysis with temporal reasoning

3. **Entity Resolution**
   - LLM-powered entity matching (>85% accuracy target)
   - Alias management
   - Confidence-based merging

### What GraphRAG Would Add

**GraphRAG Community Detection:**
- Hierarchical community structure (levels 0-N)
- Community summaries generated by LLM
- Keyword extraction per community
- Centrality scoring

**Additional Benefits:**
- Multi-hop relationship reasoning
- Automatic theme clustering
- Community-based opportunity detection
- Richer context for LLM queries

### Cost-Benefit Analysis

#### Benefits
- ✅ Better signal clustering (community detection vs. simple overlap)
- ✅ Hierarchical insights (L0: high-level themes → L2: specific issues)
- ✅ LLM-generated summaries for each community
- ✅ Enhanced multi-hop reasoning

#### Costs
- ❌ Additional Python microservice (adds complexity)
- ❌ Extra LLM API calls for community summarization
- ❌ Longer ingestion pipeline (community detection after graph sync)
- ❌ More storage (community summaries, hierarchies)
- ❌ Maintenance overhead (Python + TypeScript coordination)

### Evaluation Criteria

| Criterion | GraphRAG Needed? | Rationale |
|-----------|------------------|-----------|
| **Do we have a clustering problem?** | ⚠️ Maybe | Current opportunity detection uses entity overlap. GraphRAG could improve clustering quality, but we haven't validated that current clustering is insufficient. |
| **Do we need hierarchical insights?** | ⚠️ Maybe | Theme hierarchy exists in PostgreSQL. GraphRAG would add LLM-generated hierarchical communities, but unclear if this provides significant value over manual themes. |
| **Do we need multi-hop reasoning?** | ❌ No | Neo4j Cypher already supports multi-hop traversal (e.g., `MATCH (a)-[*1..3]->(b)`). GraphRAG doesn't add capability here. |
| **Do we have performance issues?** | ❌ No | No reported performance issues with current clustering/querying. |
| **Is clustering accuracy a blocker?** | ❌ No | No data suggesting current opportunity clustering is inaccurate. Need baseline metrics first. |
| **Are we ready for added complexity?** | ❌ No | Just removed Python microservices to simplify architecture. Adding GraphRAG re-introduces this complexity. |

### Decision Criteria for Future Re-Evaluation

**Implement GraphRAG if:**
1. **Clustering Quality Issues:** Opportunity detection produces too many false positives or misses obvious clusters
2. **User Feedback:** PMs report that themes/opportunities don't match their mental model
3. **Scale Issues:** As signal volume grows (>100K signals), simple overlap-based clustering becomes insufficient
4. **LLM Context:** Community summaries would significantly improve PM output generation quality

**Metrics to Track:**
- Opportunity false positive rate (PMs dismiss >20% of opportunities)
- Signal clustering recall (% of related signals correctly grouped)
- User satisfaction with opportunity themes

### Alternatives to GraphRAG

**If we need better clustering:**
1. **Enhance existing clustering algorithm:**
   - Use embeddings for semantic similarity (already have embedding_service)
   - Apply DBSCAN or HDBSCAN for density-based clustering
   - Use Neo4j's built-in Louvain algorithm for community detection

2. **Manual theme curation:**
   - Allow PMs to define custom themes
   - Use LLM to auto-assign signals to themes
   - Simpler than full GraphRAG pipeline

3. **Hybrid approach:**
   - Use Neo4j community detection (no Python needed)
   - Add LLM summarization only for high-value communities
   - Avoid full GraphRAG complexity

## Final Recommendation

**Defer GraphRAG to Phase 2 (post-launch)**

### Reasoning:
1. **No validated need:** Haven't tested whether current clustering is insufficient
2. **Architectural simplicity:** Just simplified by removing Python; don't add it back prematurely
3. **Focus on core flow:** Priority is end-to-end validation of Slack + forum ingestion
4. **Alternatives exist:** If clustering issues arise, can enhance with embeddings or Neo4j algorithms first

### Phase 2 Re-evaluation Triggers:
- After 1 month of production use with 10K+ signals
- If user feedback indicates clustering quality issues
- If PM output generation needs richer community context

### Immediate Actions:
- ✅ **Skip GraphRAG implementation**
- ✅ **Use Neo4j's built-in community detection** (Louvain algorithm) if needed
- ✅ **Focus on final validation tasks** (Week 8)

## Implementation Path (If Needed in Future)

If GraphRAG becomes necessary:

1. **Lightweight approach:**
   ```typescript
   // Use Neo4j built-in Louvain
   await neo4jSession.run(`
     CALL gds.louvain.stream('myGraph')
     YIELD nodeId, communityId
     RETURN gds.util.asNode(nodeId).id AS entityId, communityId
   `);
   
   // Summarize with LLM
   const communitySummary = await llm.summarize(communitySignals);
   ```

2. **Full GraphRAG:**
   - Rebuild Python GraphRAG indexer
   - Add community detection post-processing
   - Store in `graphrag_communities` table (already exists)

## Conclusion

**Decision: Defer GraphRAG implementation**

Rationale: Current system provides sufficient clustering and graph traversal capabilities. GraphRAG adds complexity without validated benefit at this stage. Will re-evaluate after production deployment based on user feedback and clustering quality metrics.

**Next Steps:** Proceed directly to Week 8 final validation tasks.
